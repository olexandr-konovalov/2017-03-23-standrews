---
title: "Building Programs With Python (2)"
author: "Leighton Pritchard"
output: 
  revealjs::revealjs_presentation:
    theme: white
    center: true
    highlight: pygments
    transition: fade
    css: reveal.css
---

# Introduction

## Goal 1

* **To learn the basic concepts of programming**

We use `Python` for this:

* we need *something* ;)
* free, well-documented, cross-platform
* widely-used

**Use what your colleagues (tend to) use**

## Goal 2

* **To analyse and visualise experimental data**

* Effectiveness of a new treatment for arthritis
* Several patients, recording inflammation on each day
* Tabular (comma-separated) data

**We can do this with a little programming**

* Why programming? **AUTOMATION**

# Setup

## Setting up - 1

Before we begin… 

* **make a neat working environment**
* obtain data

```bash
cd ~/Desktop
cd python-novice-inflammation
```

**LIVE DEMO**

# Getting Started

## Starting `Jupyter`

At the command-line, start `Jupyter` notebook:

```bash
jupyter notebook
```

## `Jupyter` landing page

<img src="images/jupyter_landing.png" />

## Create a new notebook

<img src="images/new_notebook_menu.png" height="150px" />
<img src="images/empty_notebook.png" height="150px" />
<img src="images/functions_notebook.png" height="200px" />

## Motivation

<img src="images/three_plots.png" />

* We have code to plot values of interest from multiple datasets
* **BUT** the code is long and complicated
* It's not flexible enough to deal with thousands of files
* We can't modify it easily 
* **SO** we need to package our code for reuse: **FUNCTIONS**

# FUNCTIONS

## What is a function?

* Functions in code work like mathematical functions

$$y = f(x)$$

* $f()$ is the function
* $x$ is an input (or input*s*)
* $y$ is the returned value, or output(s)

* The output $y$ depends in some way on the value of $x$ - defined by $f()$.
* **Not all functions in code take an input, or produce a usable output, but the principle is generally the same.**

## My first function

* `fahr_to_kelvin()` to convert Fahrenheit to Kelvin

$$f(x) = ((x - 32) \times \frac{5}{9}) + 273.15$$

<img src="images/python-function.svg" height="300px" />

**LIVE DEMO**

## Calling the function

* Calling `fahr_to_kelvin()` is the same as calling any other function

```python
print('freezing point of water:', fahr_to_kelvin(32))
print('boiling point of water:', fahr_to_kelvin(212))
```

**LIVE DEMO**

## Composing functions

* Composing `Python` functions works like mathematical functions: $y = f(g(x))$
* Suppose there's a function converting K to C: `kelvin_to_celsius()`
* We could convert F (`temp_f`) to C (`temp_c`) by executing the code:

```python
temp_c = kelvin_to_celsius(fahr_to_kelvin(temp_f))
```

**LIVE DEMO**


## New functions from old

* We can wrap this composed function inside a new function: `fahr_to_celsius`:

```python
def fahr_to_celsius(temp_f):
    return kelvin_to_celsius(fahr_to_kelvin(temp_f))
print('freezing point of water in Celsius:', fahr_to_celsius(32.0))
```

* **This is how programs are built: combining small bits into larger bits until the function we want is obtained**

**LIVE DEMO**

## <img src="images/exercise.png" height="75px" /> Exercise 01 (10min)

Can you write a function called `outer()` that:

* takes a single `string` *argument*
* returns a string comprising only the first and last characters of the input, e.g.

```python
print(outer("helium"))
hm
```

# ANALYSIS

## Tidying Up

* Now we can write functions
* Let's make the inflammation analysis easier to reuse: one function per operation

```python
%pylab inline

import matplotlib.pyplot
import numpy as np
import os
import seaborn
```

## `analyse()`

* We'll write a function called `analyse()` that plots the data

```python
def analyze(data):
    fig = matplotlib.pyplot.figure(figsize=(10.0, 3.0))

    axes1 = fig.add_subplot(1, 3, 1)
    axes2 = fig.add_subplot(1, 3, 2)
    axes3 = fig.add_subplot(1, 3, 3)

    axes1.set_ylabel('average')
    axes1.plot(numpy.mean(data, axis=0))

    axes2.set_ylabel('max')
    axes2.plot(numpy.max(data, axis=0))

    axes3.set_ylabel('min')
    axes3.plot(numpy.min(data, axis=0))

    fig.tight_layout()
    matplotlib.pyplot.show()
```

**LIVE DEMO**

## `detect_problems()`

* We noticed that some data was questionable
* This function spots problems with the data

```python
def detect_problems(data):
    if numpy.max(data, axis=0)[0] == 0 and numpy.max(data, axis=0)[20] == 20:
        print('Suspicious looking maxima!')
    elif numpy.sum(numpy.min(data, axis=0)) == 0:
        print('Minima add up to zero!')
    else:
        print('Seems OK!')
```

**LIVE DEMO**

## Code reuse

* Loop over the files and `analyse()` and `detect_problems()`

```python
filenames = [os.path.join('data', f) for f in os.listdir('data')
             if f.startswith('inflammation')]
             
for fname in filenames:
    data = np.loadtxt(fname, delimiter=",")
    print(fname)
    analyse(data)
    detect_problems(data)       
```

**LIVE DEMO**

# TESTING AND DOCUMENTATION

## Motivation

* Once written, functions are reused
* Functions are reused without further checks
* When functions are written:
    * test for correctness 
    * document their function
* Example: centring a numerical array

```python
def centre(data, desired):
    return (data - np.mean(data)) + desired
```

**LIVE DEMO**

## Test datasets

* We could try `centre()` on real data
    * but we don't know the answer!
* Use `numpy` to create an artificial dataset

```python
z = np.zeros((2, 2))
print(centre(z, 3.0))
```

**LIVE DEMO**

## Real data

* On real data…

```python
data = numpy.loadtxt(fname='data/inflammation-01.csv', delimiter=',')
print(centre(data, 0))
```

* But how do we know it worked?

**LIVE DEMO**

## Check properties

* We can check properties of the original and centred data
  * `mean`, `min`, `max`, `std`

```python
centred = centre(data, 0)
print('original min, mean, and max are:', numpy.min(data), numpy.mean(data), numpy.max(data))
print('min, mean, and max of centered data are:', numpy.min(centred),
      numpy.mean(centred), numpy.max(centred))
print('std dev before and after:', numpy.std(data), numpy.std(centred))      
```

**LIVE DEMO**

## Documenting functions

* Writing comments in the code (using the hash `#`) is a good thing
* `Python` provides for *docstrings*
    * These go after the function definition
    * Hook into `Python`'s help system
    
```python
def centre(data, desired):
    """Returns the array in data, recentered around the desired value."""
    return (data - numpy.mean(data)) + desired

help(centre)
```

**LIVE DEMO**

## Default arguments

* The `centre()` function *requires* two arguments
* We can specify a *default* argument in how we define the function

```python
def centre(data, desired=0.0):
    """Returns the array in data, recentered around the desired value.
    
    Example: centre([1, 2, 3], 0) => [-1, 0, 1]
    """
    return (data - np.mean(data)) + desired
centre(data, 0.0)
centre(data, desired=0.0)
centre(data)
```

**LIVE DEMO**

## <img src="images/exercise.png" height="75px" /> Exercise 02 (15min)

Can you write a function called `rescale()` that

* takes an array as input
* returns an array with values scaled to lie in the range [0.0, 1.0]
* has an informative docstring
* **HINT:** If `L` and `H` are the lowest and highest values in the original array, then the replacement for a value `v` should be `(v-L) / (H-L)`.